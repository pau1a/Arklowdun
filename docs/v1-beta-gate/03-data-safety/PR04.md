# PR-04: Guided Repair (checkpoint → rebuild → validate → swap)

## Title
Implement a guided, one-click repair flow that automatically backs up, rebuilds, validates, and atomically swaps the SQLite database.

---

## Problem
Detection (PR-01) and Backup (PR-03) prevent silent corruption and provide safety nets, but there is no way for a user to **fix** a broken database.  
We need a guided repair process that handles common corruption automatically, preserves data, and leaves users confident the app has recovered safely.

---

## Scope
### Repair Flow (Happy Path)
1. **Auto-backup**  
   - Trigger a fresh snapshot (reuse PR-03) into `backups/pre-repair-<ts>/`.
   - If backup fails → abort with error message.

2. **WAL checkpoint**  
   - If WAL exists, run `PRAGMA wal_checkpoint(FULL)` to flush pages.
   - Log outcome; continue even if fails.

3. **Rebuild via VACUUM**  
   - Run `VACUUM INTO new.sqlite3` into a temporary path.  
   - Must be atomic (no partially written DB presented).

4. **Validation**  
   - Run same checks as PR-01 on `new.sqlite3`:  
     `integrity_check`, `quick_check`, `foreign_key_check`.  
   - If all pass → continue.  
   - If fails → abort, roll back, leave old DB in place.

5. **Atomic Swap**  
   - Rename existing live DB to `pre-repair.sqlite3`.  
   - Move `new.sqlite3` into place as the live DB.  
   - Sync FS to disk.

6. **Success Banner**  
   - UI shows *“Repair complete. Your data was verified and restored safely.”*  
   - Provide “Reveal backup” button to open pre-repair snapshot.

### UI Surface
- Settings → “Repair Database” button (only enabled when health ≠ OK).  
- Modal dialog:  
  - Stepper with status (Backup → Checkpoint → Rebuild → Validate → Swap).  
  - Progress spinner for long steps.  
  - Cancel disabled mid-operation to avoid partial swaps.  
- Success path: green checkmark, backup location link.  
- Failure path: red banner with reason + guidance (“Your database remains in read-only mode. Try Hard Repair.”).

### CLI Surface
- Command: `arklowdun db repair`
  - STDOUT step-by-step logs.  
  - Exit 0 if repaired, 1 if failed.  
  - On failure, path to pre-repair backup printed.

---

## Acceptance Criteria
- On typical corruption (WAL bloat, minor page errors), guided repair completes and health status = OK.  
- On unrecoverable corruption, guided repair fails gracefully; old DB untouched, app remains read-only.  
- Pre-repair backup always exists after attempted repair (success or failure).  
- Atomic swap guarantees no partial DB ever used.  
- Tests:
  - Healthy DB → repair runs, exits early, reports “already healthy”.  
  - Corrupted WAL → repaired DB passes checks.  
  - Inject bad page → rebuild fails, rollback succeeds, old DB intact.  
  - Power-cut simulation (kill mid-VACUUM) → on next start, old DB remains intact.

---

## Non-Goals / Out of Scope
- Complex table-by-table salvage (that is PR-05).  
- Export/import round-trip (PR-06/07).  
- Cloud repair.

---

## Risks & Mitigations
- **Long-running VACUUM**: show progress UI, keep app responsive, block new write IPC during operation.  
- **Disk space exhaustion**: preflight check requires at least 2× DB size free.  
- **Unexpected crash mid-repair**: always perform backup before touching live DB; atomic swap ensures rollback safety.

---

## Deliverables
- `src-tauri/src/db/repair.rs` (repair engine).  
- `src-tauri/src/db/swap.rs` (atomic file swap util).  
- UI: `RepairView.tsx` in Settings with modal + progress stepper.  
- CLI: `arklowdun db repair`.  
- Tests:
  - Unit: WAL checkpoint outcomes, validation paths.  
  - Integration: corrupt fixtures exercised end-to-end.  
  - E2E: simulated power loss leaves DB intact.

---

## Exit Condition
- App provides a one-click guided repair that fixes common corruption automatically.  
- Users always end with either:  
  - A healthy live DB, or  
  - A clear failure state with old DB intact and readable.  
- No path exists where data is lost silently.
