# PR-05: Hard Repair (table export/import with FK graph)

## Title
Implement a last-resort repair mechanism that reconstructs a new database by exporting/importing tables in dependency order, with a recovery report for skipped rows.

---

## Problem
Guided Repair (PR-04) fixes common corruption via VACUUM INTO, but severe corruption (bad pages, FK violations, broken indexes) may prevent VACUUM from completing.  
We need a **hard repair path** that salvages as much valid data as possible, surfaces what was lost, and leaves the user with a working DB plus an omissions report.

---

## Scope
### Hard Repair Flow
1. **Pre-backup**
   - Run PR-03 snapshot into `backups/hard-repair-pre-<ts>/`.
   - Abort if backup fails.

2. **Schema Rebuild**
   - Recreate schema from the latest migration scripts (known-good source of truth).
   - Write schema to `new.sqlite3`.

3. **Export by Table**
   - Enumerate tables and foreign key graph from `PRAGMA foreign_key_list`.
   - Export rows table-by-table in FK-safe order.
   - For each row:
     - Validate constraints before insert.
     - If insert fails, log and skip row.

4. **Import into New DB**
   - Insert valid rows into `new.sqlite3`.
   - Track counts per table: attempted, succeeded, failed.

5. **Validation**
   - Run integrity/foreign_key_check on `new.sqlite3`.
   - If passes → continue.  
   - If fails → mark as partial success but still present DB to user.

6. **Atomic Swap**
   - Archive old DB to `pre-hard-repair.sqlite3`.
   - Move `new.sqlite3` into place as live DB.

7. **Recovery Report**
   - Generate `recovery-report.json`:
     ```json
     {
       "app_version": "0.1.0",
       "tables": {
         "events": { "attempted": 12000, "succeeded": 11980, "failed": 20 },
         "notes": { "attempted": 5000, "succeeded": 5000, "failed": 0 }
       },
       "skipped_examples": [
         { "table": "events", "rowid": 42, "error": "foreign key mismatch" }
       ],
       "completed_at": "2025-09-23T11:00:00Z"
     }
     ```
   - Save under `backups/hard-repair-<ts>/`.

### UI Surface
- Triggered when Guided Repair fails or manually via Settings → “Hard Repair”.
- Modal similar to PR-04 but warns clearly:  
  *“Hard Repair may recover most data but some records may be lost. A recovery report will be generated.”*
- On success: banner *“Hard Repair complete. 20 records could not be restored — view report.”*
- Report downloadable via button (opens JSON in default editor or copies path).

### CLI Surface
- Command: `arklowdun db hard-repair`
  - STDOUT: summary counts per table, path to recovery report.
  - Exit code:
    - 0 if completed with all rows.
    - 1 if completed with omissions.
    - 2 if unrecoverable failure.

---

## Acceptance Criteria
- Severe corruption (e.g., broken indexes, FK loops) → Hard Repair runs and produces a usable DB.  
- All omitted rows logged with table + rowid + error.  
- Old DB always preserved.  
- Recovery report always generated.  
- Tests:
  - Synthetic corruption: one table unreadable → others imported fine; report lists missing rows.
  - Corrupted FK relationships: invalid rows skipped, valid rows preserved.
  - Power loss simulation: rollback safe; old DB intact.

---

## Non-Goals / Out of Scope
- Full forensic recovery of binary pages.  
- Cloud sync of recovery reports.  
- User-friendly re-entry of lost rows (manual, not automated).

---

## Risks & Mitigations
- **Performance**: table-by-table export/import can be slow.  
  - Mitigation: chunked inserts, progress updates in UI.  
- **Partial recovery confusion**: user must know what was lost.  
  - Mitigation: JSON recovery report with counts + examples.  
- **FK loops**: handle via topological sort; log unresolved references.

---

## Deliverables
- `src-tauri/src/db/hard_repair.rs` (engine).  
- `src-tauri/src/db/schema_rebuild.rs` (generate new schema).  
- UI: Settings → `HardRepairView.tsx` with modal + progress.  
- CLI: `arklowdun db hard-repair`.  
- Tests:
  - Unit: schema rebuild, FK graph traversal, omission logging.
  - Integration: corrupt fixtures, power loss.
  - E2E: simulate severe corruption, confirm partial recovery + report.

---

## Exit Condition
- Users have a last-resort Hard Repair that reconstructs a usable DB from corrupted data.  
- Old DB always preserved.  
- Recovery report is generated every time, listing omissions clearly.  
- No silent loss of data.
