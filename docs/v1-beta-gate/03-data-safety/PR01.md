# PR-01: Startup DB Health Checks

## Title
Add mandatory SQLite health checks at startup with structured reporting and UI/CLI surfacing.

---

## Problem
Currently, the application assumes the SQLite database is healthy on launch.  
If corruption exists (bad pages, FK violations, WAL issues), the app may proceed to write, amplifying damage.  
We need a **deterministic health gate** that runs on every startup and blocks unsafe writes until repair.

---

## Scope
### Health Checks
- Run synchronously at startup **before** enabling any mutating IPC.
- Checks to run:
  - `PRAGMA integrity_check=1` (full check, capped by timeout).
  - `PRAGMA quick_check` (fast heuristic).
  - `PRAGMA foreign_key_check`.
  - WAL file presence and size sanity.
  - Page size and journal mode match expected values.
- Collect per-check status (pass/fail, timing, message).

### Structured Health Report
- Common schema (Rust → TS binding):
  ```ts
  type DbHealthReport = {
    status: "ok" | "error";
    checks: {
      name: string;
      passed: boolean;
      duration_ms: number;
      details?: string;
    }[];
    offenders?: { table: string; rowid: number; message: string }[];
    schema_hash: string;
    app_version: string;
    generated_at: string; // ISO8601 UTC
  }
````

* Must be serialisable to JSON for CLI and IPC.

### UI Surface

* **Healthy:** silent, log “DB\_HEALTH\_OK”.
* **Unhealthy:** persistent banner at top of app:

  * Title: “Database issue detected.”
  * Subtitle: “Editing is disabled until repair completes.”
  * Button: “View Details” (drawer/panel shows full report).
* States covered: healthy, unhealthy, running check (spinner).

### CLI Surface

* Add command `db status`:

  * `--json`: machine-readable health report.
  * Default: human-readable table of checks and results.
* Return non-zero exit code if `status = error`.

### IPC Guard (integration point for PR-02)

* Provide health result over IPC.
* Must be cached in memory; refreshable on demand (`db.recheck()`).

---

## Acceptance Criteria

* Startup always runs checks before write access is possible.
* Healthy DB: log line `[DB_HEALTH_OK]`, app functions normally.
* Unhealthy DB: banner shown, writes blocked (blocked by PR-02).
* CLI `db status` produces identical data to IPC `getHealthReport`.
* Unit tests cover:

  * Clean DB → status: ok.
  * Broken FK → status: error, offender listed.
  * WAL junk file → status: error, check flagged.
  * Page size mismatch → status: error, flagged.
* Integration test: corrupted fixture triggers banner + non-zero CLI exit.

---

## Non-Goals / Out of Scope

* Backup/repair (covered in PR-03/04).
* Export/import (covered in PR-06/07).
* User-facing recovery flows (only detection here).

---

## Risks & Mitigations

* **Performance:** full integrity\_check can be slow on huge DBs.

  * Mitigation: run `quick_check` first; if it fails, escalate to full check.
  * Cap runtime with timeout; show warning if truncated.
* **False positives:** WAL in mid-transaction may trigger noise.

  * Mitigation: checkpoint before checks if WAL present.
* **User panic:** banner wording must be calm and actionable.

  * Provide clear link to “Repair” (hook for PR-04).

---

## Deliverables

* New module: `src-tauri/src/db/health.rs` → performs checks and builds report.
* IPC endpoint: `db.getHealthReport()`.
* CLI command: `arklowdun db status [--json]`.
* UI components:

  * `DbHealthBanner.tsx` (banner).
  * `DbHealthDrawer.tsx` (details).
* Docs:

  * `docs/admin/db-ops.md` updated with `db status` usage.

---

## Exit Condition

* On any startup, the app can *prove* DB health state.
* Users see a clear, actionable banner when corruption exists.
* CLI/IPC return identical structured reports.
* Mutations are not permitted until PR-02 is in place.
