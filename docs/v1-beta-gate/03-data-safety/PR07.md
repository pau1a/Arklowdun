# PR-07: Import with Preflight (merge/replace + dry-run)

## Title
Implement an import workflow that validates bundles before execution, supports merge/replace modes, and guarantees deterministic outcomes.

---

## Problem
Export (PR-06) lets users take their data out, but there is no way to bring it back in.  
We need a robust **import path** that:
- Validates bundle integrity before writing.  
- Supports both *Replace* (wipe + load) and *Merge* (newer-wins).  
- Provides a **dry-run plan** so users know exactly what will happen.  
- Guarantees consistency between plan and execution.

---

## Scope
### Preflight Validation
- Read `manifest.json` from export bundle.
- Checks:
  - Schema version compatibility (must match live DB schema).
  - App version compatibility (≥ minimum supported).
  - Free disk space ≥ bundle size.
  - SHA256 verification of all files (data + attachments).
- Outcome:
  - Success → continue.
  - Failure → abort with explicit error (e.g. “Version mismatch”).

### Modes
- **Replace**
  - Drop existing DB, recreate schema, import all bundle data.
  - Copy all attachments.
- **Merge**
  - For each record:
    - If ID not present → insert.
    - If ID present → compare `updated_at` (or equivalent).  
      - If bundle record newer → replace.  
      - If live record newer → keep live record.  
    - Log conflicts (bundle vs live).
  - Attachments:
    - If attachment missing locally but present in bundle → copy.
    - If both exist but hashes differ → newer-wins policy.

### Dry-Run
- Run full validation + conflict detection **without writing**.  
- Generate plan:
  ```json
  {
    "mode": "merge",
    "tables": {
      "events": { "adds": 50, "updates": 10, "skips": 5 },
      "notes": { "adds": 20, "updates": 0, "skips": 0 }
    },
    "attachments": { "adds": 12, "updates": 3, "skips": 1 }
  }
````

* Show plan to user before confirming.

### Execution

* Apply plan deterministically.
* Import in chunks (e.g., 500 rows per transaction).
* Attachments copied with integrity check (sha256).
* Report generated after execution (counts, conflicts, skipped).

### UI Surface

* Settings → “Import Data”:

  * Step 1: Choose bundle folder.
  * Step 2: Preflight validation (disk space, version, hashes).
  * Step 3: Show dry-run plan with counts + conflicts.
  * Step 4: Confirm → progress modal (tables, attachments).
  * Success: *“Import complete. 5000 notes, 12000 events, 300 attachments imported.”*
  * Failure: banner with error + link to report.

### CLI Surface

* Command: `arklowdun db import --in <path> [--mode merge|replace] [--dry-run]`
* Dry-run prints plan JSON to STDOUT.
* Real run prints applied counts + report path.
* Exit code:

  * 0 success.
  * 1 validation error.
  * 2 execution error.

---

## Acceptance Criteria

* Preflight catches version mismatch, bad hashes, or missing files with explicit errors.
* Dry-run plan = actual execution (counts match).
* Replace mode wipes DB clean and repopulates deterministically.
* Merge mode resolves conflicts by timestamp, logs decisions, no nondeterminism.
* Attachments always integrity-checked; mismatches reported.
* Tests:

  * Import bundle with version mismatch → blocked.
  * Merge bundle with conflicting updates → newer wins, conflict logged.
  * Replace bundle → DB identical to export.
  * Dry-run vs execution consistency proven.

---

## Non-Goals / Out of Scope

* Cross-schema migration imports (only exact schema supported).
* Cloud-based imports.
* Interactive conflict resolution UI (only policy-driven).

---

## Risks & Mitigations

* **Large imports**: may run long.

  * Mitigation: chunked inserts, progress reporting.
* **Conflicts misunderstood by users**:

  * Mitigation: dry-run plan always shown before execution.
* **Disk exhaustion mid-import**:

  * Mitigation: preflight free-space check; rollback if insert transaction fails.

---

## Deliverables

* `src-tauri/src/import/mod.rs` (engine).
* `src-tauri/src/import/validator.rs` (preflight validation).
* UI: `ImportView.tsx` in Settings with multi-step flow.
* CLI: `arklowdun db import --in <path>`.
* Tests:

  * Unit: validator, dry-run plan builder.
  * Integration: merge vs replace with conflicts.
  * E2E: export bundle → import → counts match.

---

## Exit Condition

* Users can safely re-import data from an export bundle.
* They always see a deterministic plan first.
* Merge and Replace modes both work and are verifiable.
* No silent conflicts or skipped rows — all decisions logged.
