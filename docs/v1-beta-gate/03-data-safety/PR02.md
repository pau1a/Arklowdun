# PR-02: Write-path Guardrail

## Title
Block all mutating IPC commands when database health is not OK.

---

## Problem
PR-01 establishes detection of database corruption at startup, but detection is meaningless if the app can still perform writes.  
We need a **hard guardrail** at the IPC layer: when health ≠ OK, all mutating commands must fail deterministically with a stable error code and user-facing guidance.

---

## Scope
### Guard Implementation
- Central guard function wrapping all IPC entry points that modify data.
- If `DbHealthReport.status != ok`, block the command before execution.
- Return structured error:
  ```ts
  {
    code: "DB_UNHEALTHY_WRITE_BLOCKED",
    message: "Database integrity checks failed. Editing is disabled until repair completes.",
    crash_id?: string,
    health_report?: DbHealthReport
  }
````

### Covered Commands

* Create, update, delete, and restore operations across **all features**:

  * Files (create/update/delete/restore).
  * Events (create/update/delete/restore).
  * Notes (create/update/delete/restore).
  * Imports.
* Bulk/migration helpers that write must also be blocked.

### IPC & TypeScript

* IPC guard sits in `src-tauri/src/ipc/guard.rs`.
* All mutating Rust commands call guard first.
* TypeScript error handler (`normalizeError`) maps code to stable UI messages.

### UI Surface

* When blocked, UI shows banner from PR-01:
  *“Database issue detected. Editing is disabled until repair completes.”*
* Banner includes “Repair” button (launches PR-04 flow once implemented).
* Individual write attempts surface a toast with the same message, no stack traces.

### CLI Surface

* Mutating CLI commands exit immediately with code 2.
* STDERR message:
  `Error: DB_UNHEALTHY_WRITE_BLOCKED. Run 'arklowdun db status' or repair.`

---

## Acceptance Criteria

* All mutating IPCs (files/events/notes/import) return the stable error when health ≠ OK.
* Read-only commands (list/get/search/export) are unaffected.
* Banner is shown globally when DB unhealthy, even without attempting writes.
* E2E test: inject FK violation → app blocks “create file” with correct error.
* CLI test: same corrupted DB → mutating CLI command exits 2, prints error.

---

## Non-Goals / Out of Scope

* Actual repair workflows (PR-04/05).
* Backup creation (PR-03).
* Export/import (PR-06/07).

---

## Risks & Mitigations

* **Developer bypass:** direct Rust calls skipping guard.

  * Mitigation: enforce `#[must_use]` health guard wrapper; add lint check in CI.
* **Confusion for users:** multiple errors.

  * Mitigation: unify under single banner + stable error string.

---

## Deliverables

* `src-tauri/src/ipc/guard.rs` (new guard module).
* Modified IPC handlers to call guard.
* Updated error taxonomy (`AppError::DbUnhealthy`).
* TS error normalization → `showError` → banner/toast.
* CLI mutating commands updated to consult health and exit early.
* Tests:

  * Unit: guard returns correct error when unhealthy.
  * Integration: corrupt DB fixture blocks write commands.
  * E2E: banner displayed, CLI exit code = 2.

---

## Exit Condition

* On a corrupted DB, **no write path can execute**.
* App surfaces consistent banner + toast.
* CLI and IPC return identical structured error.
* Mutations remain blocked until DB is repaired (PR-04).

