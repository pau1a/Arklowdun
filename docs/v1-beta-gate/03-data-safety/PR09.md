# PR-09: Operation Reports (per-op JSON artefacts)

## Title
Generate structured JSON reports for every DB safety/recovery operation (health, backup, repair, export, import) and surface them in UI/CLI.

---

## Problem
Users and maintainers need concrete evidence of what happened during operations.  
Logs alone are insufficient: we need a **stable artefact** for each run, so outcomes can be audited, compared, and attached to support requests.  
Without reports, debugging corruption or recovery is opaque.

---

## Scope
### Report Schema
- Common JSON structure for all operations:
  ```json
  {
    "id": "op-20250923-abc123",
    "operation": "backup", // health | backup | repair | hard_repair | export | import
    "started_at": "2025-09-23T12:00:00Z",
    "finished_at": "2025-09-23T12:00:05Z",
    "status": "success", // success | failed | partial
    "app_version": "0.1.0",
    "schema_version": "0001_baseline",
    "details": {
      "tables": { "events": { "count": 10000 } },
      "attachments": { "count": 300, "bytes": 524288000 },
      "errors": []
    }
  }
````

* Each op populates `details` differently:

  * Health: checks\[], offenders\[].
  * Backup: file path, manifest, size, sha256.
  * Repair: steps, outcome, backup path.
  * Hard Repair: attempted/succeeded/failed per table, omissions list path.
  * Export: export path, manifest, counts, hashes.
  * Import: mode, dry-run plan, applied counts, conflicts.

### Storage

* Location:

  ```
  $APPDATA/arklowdun/reports/<operation>-<timestamp>.json
  ```
* Keep last 50 per operation type by default.
* Evict oldest-first when exceeding quota.

### UI Surface

* Settings → “Reports” panel:

  * List last 10 reports across all ops.
  * Show table with: operation, status, started\_at, finished\_at.
  * Action: “Open Report” → opens JSON in default editor or embedded viewer.
* After any op completes, show toast:
  *“Report saved: backup-20250923-1200.json”* with “Open” button.

### CLI Surface

* Every command (`db status`, `db backup`, `db repair`, `db export`, `db import`) writes a JSON report file on completion.
* Path printed to STDOUT:
  `Report: $APPDATA/arklowdun/reports/backup-20250923-1200.json`

---

## Acceptance Criteria

* Every operation generates a JSON report in the reports folder.
* Reports follow stable schema; schema drift covered by version field.
* UI shows list of reports; clicking one opens JSON.
* CLI always prints path of latest report.
* Tests:

  * Backup → report includes path, size, sha256.
  * Failed repair → report status = failed, includes error.
  * Hard repair with omissions → report status = partial, lists counts.
  * Export/import → report includes counts, hashes, conflicts.
  * Health check → report lists all checks, offenders if any.

---

## Non-Goals / Out of Scope

* Telemetry upload.
* Cloud sync of reports.
* Human-friendly PDF/HTML outputs (JSON only for now).

---

## Risks & Mitigations

* **User confusion at raw JSON**: mitigate with viewer in UI, but JSON is still primary artefact.
* **Large report files**: keep content to metadata, counts, errors—not raw row dumps.
* **Schema evolution**: include `report_version` key, bump if fields change.

---

## Deliverables

* `src-tauri/src/ops/reporting.rs` (report writer).
* Integrations in:

  * `health.rs`, `backup.rs`, `repair.rs`, `hard_repair.rs`, `export.rs`, `import.rs`.
* UI: `ReportsList.tsx` in Settings.
* CLI: print `Report:` line at end of each op.
* Tests:

  * Unit: schema compliance (JSON schema validation).
  * Integration: run each op, report file appears, parse matches expected.
  * E2E: UI lists reports, “Open” action works.

---

## Exit Condition

* Every operation produces a JSON artefact saved to disk.
* Reports are visible in UI and discoverable via CLI.
* Users and support can always point to a file proving what happened.
