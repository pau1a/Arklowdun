# EXDATE Normalisation

Recurring events rely on `EXDATE` values to suppress specific instances that
would otherwise be generated by the RRULE. Historical data stored a comma
separated list of timestamps without any validation, which led to duplicates,
invalid formats, and strings that fell outside the recurrence window. This
normalisation pass defines a strict contract for both inbound payloads and
stored values.

## Canonical format

* Every exclusion is persisted as an ISO-8601 timestamp in UTC with a trailing
  `Z` suffix, e.g. `2025-03-02T09:00:00Z`.
* Values are sorted chronologically in ascending order.
* Duplicate timestamps are removed automatically.
* Empty strings or whitespace-only lists are treated as `NULL` (no exclusions).

## Validation rules

The backend validates `EXDATE` payloads before writing them to the database:

1. **Format enforcement** – strings must parse as ISO-8601 timestamps and must
   end with `Z`. Any offsets (`+02:00`, `-05:00`) or non-standard formats are
   rejected with `E_EXDATE_INVALID_FORMAT`.
2. **Recurrence window guard** – exclusions must fall between the event start
   time and the RRULE's `UNTIL` (when present). Values outside that window are
   rejected with `E_EXDATE_OUT_OF_RANGE`.
3. **Recurrence required** – attempts to store exclusions without a companion
   RRULE are rejected. Clearing the RRULE automatically removes all exclusions.
4. **Start timestamp sanity** – the event must expose a valid UTC start (either
   `start_at_utc` or `start_at`). Invalid/missing timestamps cause validation to
   fail so that downstream recurrence expansion remains consistent.

## Migration behaviour

The `normalize_existing_exdates` migration runs automatically during startup:

* Existing `EXDATE` strings are tokenised, parsed, deduplicated and sorted.
* Malformed entries (missing `Z`, unparsable timestamps) are dropped and counted.
* Values before the event start or after the RRULE `UNTIL` are removed.
* Blank strings are converted to `NULL`.
* A summary log entry (`exdate_migration_summary`) records the number of rows
  scanned, updated, cleared and the counts of invalid or out-of-range values.
  Separate warning logs capture sample invalid/out-of-range entries.

## Error catalogue

| Code                     | Message                                                            |
|--------------------------|--------------------------------------------------------------------|
| `E_EXDATE_INVALID_FORMAT`| "Excluded dates must use ISO-8601 UTC format (YYYY-MM-DDTHH:MM:SSZ)." |
| `E_EXDATE_OUT_OF_RANGE`  | "Excluded dates must fall within the recurrence window."           |

Both IPC and CLI surfaces now surface normalised strings exclusively. Downstream
consumers (UI, CLI tools, and tests) can rely on deterministic formatting and
ordering, which keeps snapshots and comparisons stable.

## Examples

| Input                                                        | Result                                                            |
|-------------------------------------------------------------|-------------------------------------------------------------------|
| `"2025-03-02T09:00:00Z, 2025-03-01T09:00:00Z"`              | `"2025-03-01T09:00:00Z,2025-03-02T09:00:00Z"`                    |
| `"2025-03-02T09:00:00+02:00"`                               | Rejected – `E_EXDATE_INVALID_FORMAT`                              |
| `"2025-03-02T09:00:00Z, 2025-02-20T09:00:00Z"` (start 25 Feb)| Rejected – second value triggers `E_EXDATE_OUT_OF_RANGE`           |
| `"2025-03-02T09:00:00Z,2025-03-02T09:00:00Z,not-a-date"`    | Stored as `"2025-03-02T09:00:00Z"`; invalid token dropped in migration |

Adhering to these rules keeps EXDATE handling deterministic, prevents silent
skips during recurrence expansion, and simplifies troubleshooting when payloads
are malformed.
