# Vehicles IPC Surface

### Purpose

Explain how Vehicles data crosses the Rust ↔ TypeScript boundary, which commands exist today, and what validation/error semantics callers must expect.

---

## 1. Endpoint summary

| Command                    | Purpose                                      | Request fields                                                                                   | Response |
| -------------------------- | -------------------------------------------- | ------------------------------------------------------------------------------------------------ | -------- |
| `vehicles_list`            | List active vehicles for a household         | `householdId` (string), optional `orderBy`, `limit`, `offset` (not used by the UI)               | Array of vehicle objects.
| `vehicles_get`             | Fetch a single vehicle                       | `householdId` (string), `id` (string)                                                            | Vehicle object or `null`.
| `vehicles_create`          | Insert a vehicle                             | `data` map; must include `household_id`, `name`, and at least one of `reg`/`vin`                 | Newly created vehicle JSON.
| `vehicles_update`          | Update mutable fields                        | `householdId` (string), `id` (string), partial `data` payload                                    | `void`.
| `vehicles_delete`          | Soft-delete a vehicle                        | `householdId` (string), `id` (string)                                                            | `void`.
| `vehicles_restore`         | Clear `deleted_at`                           | `householdId` (string), `id` (string)                                                            | `void`.

All six commands are generated by `gen_domain_cmds_ns!` in `src-tauri/src/lib.rs` and ultimately dispatch into the shared helpers in `src-tauri/src/commands.rs`.

---

## 2. Behaviour details

### 2.1 Listing and retrieval

`vehicles_list` calls `commands::list`, which recognises the special-case table name and executes the bespoke SQL in `list_vehicles`. The query selects every column, aliases `next_mot_due` / `next_service_due` from legacy columns when missing, and filters on `deleted_at IS NULL`. Results are deserialised into the Rust `Vehicle` struct before serialising back to JSON. The TypeScript repo (`src/db/vehiclesRepo.ts`) normalises the `next_*` fields to `undefined` when zero.

`vehicles_get` requires a household identifier (guarded at runtime—missing values produce `COMMANDS/MISSING_HOUSEHOLD`). It reuses `get_vehicle`, so callers receive the same field set as the list. When no row matches the ID, the command returns `null`.

### 2.2 Mutations

`vehicles_create` and `vehicles_update` both use `commands::create` / `commands::update`. Key traits:

- Validation happens on the TypeScript side via `src/lib/ipc/contracts/index.ts`. The contract enforces `name` presence, uppercase/length rules for `reg` and `vin`, and a custom refinement that rejects payloads lacking both values.
- The helpers inject UUIDv7 IDs, millisecond timestamps, and default `position` when absent. Because Vehicles itself does not carry attachments, the attachment guard is a no-op (`ATTACHMENT_TABLES` does not include `vehicles`).
- SQLite uniqueness violations on `reg` or `vin` surface as `Sqlite/2067` errors. The integration tests assert the `constraint` context is set to `uq_vehicles_household_reg` or `uq_vehicles_household_vin` so the UI can display specific guidance later.

`vehicles_delete` calls `commands::delete`, which writes `deleted_at` and leaves the row in place for potential restoration. There is no hard-delete path; the only cascading delete is via household removal. `vehicles_restore` simply nulls `deleted_at` using `commands::restore`.

### 2.3 Maintenance endpoints

The macro also exposes `vehicle_maintenance_list/get/create/update/delete/restore`, but these routes do not enrich the payload beyond raw table columns. They run through the generic helpers (`commands::list`, `commands::create`, etc.) without the vehicle-specific SELECT statement, and the UI never invokes them. There is no server-side join: maintenance rows must be fetched separately if/when the UI evolves.

---

## 3. SQL locations

- List/get SQL lives in `src-tauri/src/commands.rs` (`list_vehicles`, `get_vehicle`).
- Insert/update/delete statements are generated dynamically inside `commands::create` / `commands::update` / `repo::set_deleted_at`.
- TypeScript entry points sit in `src/db/vehiclesRepo.ts`, which wraps `@lib/ipc/call` and reuses the contracts compiled to `src/bindings/Vehicle.ts`.

---

## 4. Error handling expectations

| Scenario                               | Behaviour |
| -------------------------------------- | --------- |
| Missing household on `vehicles_get`    | `COMMANDS/MISSING_HOUSEHOLD` error.
| Duplicate `reg` or `vin`               | `Sqlite/2067` with `constraint` context set to the violated index.
| Creating/updating without `reg` & `vin`| Contract rejection before the Rust layer, returning a Zod validation error to the caller.
| Requesting deleted vehicles            | `vehicles_list` omits them; `vehicles_get` returns `null`.
| IPC failure / DB unhealthy             | `showError` translates the error into a toast; there is no bespoke Vehicles error UI.

---

**Status:** IPC layer exercised by `vehicles_schema.rs` tests and legacy UI smoke paths.

**Scope:** Commands and validation for the Vehicles domain.

**File:** `/docs/vehicles/ipc.md`
